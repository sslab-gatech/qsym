##############################################################
#
# This file includes all the test targets as well as all the
# non-default build rules and test recipes.
#
##############################################################


##############################################################
#
# Test targets
#
##############################################################

###### Place all generic definitions here ######

# This defines tests which run tools of the same name.  This is simply for convenience to avoid
# defining the test name twice (once in TOOL_ROOTS and again in TEST_ROOTS).
# Tests defined here should not be defined in TOOL_ROOTS and TEST_ROOTS.
TEST_TOOL_ROOTS := icache dcache allcache dcache_xscale_config footprint memalign address_mapping address_mapping_probe \
                   memory_limit

# This defines the tests to be run that were not already defined in TEST_TOOL_ROOTS.
TEST_ROOTS := memory_allocation_access_protection new_delete address_mapping_oom address_mapping_zero

# This defines a list of tests that should run in the "short" sanity. Tests in this list must also
# appear either in the TEST_TOOL_ROOTS or the TEST_ROOTS list.
# If the entire directory should be tested in sanity, assign TEST_TOOL_ROOTS and TEST_ROOTS to the
# SANITY_SUBSET variable in the tests section below (see example in makefile.rules.tmpl).
SANITY_SUBSET := memory_allocation_access_protection

# This defines the tools which will be run during the the tests, and were not already defined in
# TEST_TOOL_ROOTS.
TOOL_ROOTS := memory_allocation_from_app_access_protection_tool memory_allocation_from_tool_access_protection_tool \
              new_delete_tool

# This defines all the applications that will be run during the tests.
APP_ROOTS := access_protection_app new_delete_app mmap_reader_app

# This defines any additional object files that need to be compiled.
OBJECT_ROOTS :=

# This defines any additional dlls (shared objects), other than the pintools, that need to be compiled.
DLL_ROOTS :=

# This defines any static libraries (archives), that need to be built.
LIB_ROOTS :=

###### Place architecture-specific definitions here ######

ifeq ($(TARGET),intel64)
    TEST_TOOL_ROOTS += big_malloc
endif

###### Place OS-specific definitions here ######

# Android
ifeq ($(TARGET_OS),android)
    TEST_TOOL_ROOTS += memalloc memalloc2
endif

# Linux
ifeq ($(TARGET_OS),linux)
    TEST_TOOL_ROOTS += memalloc memalloc2 restrict_memory_vdso
    TEST_ROOTS += restrict_memory restrict_memory_stack
    APP_ROOTS += print_vdso print_stack
endif

# Windows
ifeq ($(TARGET_OS),windows)
    TEST_TOOL_ROOTS += memalloc memalloc2
endif

###### Handle exceptions here ######

# Android
ifeq ($(TARGET_OS),android)
    ifeq ($(NDK_VERSION),10)
        # memalloc, big_malloc: The memory allocation causes a soft reboot in Android. See mantis 3308.
        TEST_TOOL_ROOTS := $(filter-out big_malloc memalloc, $(TEST_TOOL_ROOTS))
    endif
endif

# Mac OS X*
ifeq ($(TARGET_OS),mac)
    TEST_TOOL_ROOTS := $(filter-out address_mapping_probe, $(TEST_TOOL_ROOTS))
endif


##############################################################
#
# Test recipes
#
##############################################################

# This section contains recipes for tests other than the default.
# See makefile.default.rules for the default test rules.
# All tests in this section should adhere to the naming convention: <testname>.test

# Checks the correctness of the APIs: PIN_CheckReadAccess and PIN_CheckWriteAccess.
memory_allocation_access_protection.test: $(OBJDIR)memory_allocation_from_tool_access_protection_tool$(PINTOOL_SUFFIX) $(OBJDIR)memory_allocation_from_app_access_protection_tool$(PINTOOL_SUFFIX) $(OBJDIR)access_protection_app$(EXE_SUFFIX)
	$(PIN) -t $(OBJDIR)memory_allocation_from_tool_access_protection_tool$(PINTOOL_SUFFIX) \
	  -o $(OBJDIR)memory_allocation_from_tool_access_protection.out -- $(OBJDIR)access_protection_app$(EXE_SUFFIX) 2
	$(QGREP) "0011" $(OBJDIR)memory_allocation_from_tool_access_protection.out
	$(PIN) -t $(OBJDIR)memory_allocation_from_app_access_protection_tool$(PINTOOL_SUFFIX) \
	  -o $(OBJDIR)memory_allocation_from_app_access_protection.out -- $(OBJDIR)access_protection_app$(EXE_SUFFIX) 1
	$(QGREP) "00" $(OBJDIR)memory_allocation_from_app_access_protection.out
	$(QGREP) "11" $(OBJDIR)memory_allocation_from_app_access_protection.out
	$(RM) $(OBJDIR)memory_allocation_from_app_access_protection.out
	$(RM) $(OBJDIR)memory_allocation_from_tool_access_protection.out

# In this test the tool does repeated mallocs in it's Fini function until it gets a NULL return value
# It tests that PIN's malloc supplied to the tool correctly returns NULL when out of memory
# A separate test is still needed to get PIN to internally exhaust memory and see that PIN
# outputs the "Out of memory" message to the pin logfile before exiting.
memalloc.test: $(OBJDIR)memalloc$(PINTOOL_SUFFIX) $(TESTAPP)
	$(RM) -f $(OBJDIR)memalloc.out
	$(PIN) -t $(OBJDIR)memalloc$(PINTOOL_SUFFIX) -o $(OBJDIR)memalloc.out -- $(TESTAPP) makefile $(OBJDIR)memalloc.makefile.copy
	$(QGREP) NULL $(OBJDIR)memalloc.out
	$(RM) $(OBJDIR)memalloc.out $(OBJDIR)memalloc.makefile.copy

memalloc2.test: $(OBJDIR)memalloc2$(PINTOOL_SUFFIX) $(TESTAPP)
	$(RM) -f $(OBJDIR)memalloc2.out
	$(PIN) -t $(OBJDIR)memalloc2$(PINTOOL_SUFFIX) -o $(OBJDIR)memalloc2.out -- $(TESTAPP) makefile $(OBJDIR)memalloc2.makefile.copy
	$(QGREP) OutOfMem $(OBJDIR)memalloc2.out
	$(RM) $(OBJDIR)memalloc2.out $(OBJDIR)memalloc2.makefile.copy

new_delete.test: $(OBJDIR)new_delete_tool$(PINTOOL_SUFFIX) $(OBJDIR)new_delete_app$(EXE_SUFFIX)
	$(PIN) -xyzzy -statistic -logfile $(OBJDIR)new_delete.log -t $(OBJDIR)new_delete_tool$(PINTOOL_SUFFIX) \
	  -- $(OBJDIR)new_delete_app$(EXE_SUFFIX)
	numToolBytes=`$(GREP) 'mem::bytes::RawMmap/tool ' ./$(OBJDIR)new_delete.log | $(SED) -e 's/.*norm: *[0-9\.]*//' | $(SED) -e 's/\/.*//' | $(SED) -e 's/,//g'`; \
	  $(BASHTEST) `$(EXPR) $$numToolBytes \< 1000000` -eq "1"
	$(RM) $(OBJDIR)new_delete.log

memalign.test: $(OBJDIR)memalign$(PINTOOL_SUFFIX) $(TESTAPP)
	$(RM) -f $(OBJDIR)memalign.out
	$(PIN) -t $(OBJDIR)memalign$(PINTOOL_SUFFIX) -o $(OBJDIR)memalign.out \
	  -- $(TESTAPP) makefile $(OBJDIR)memalign.makefile.copy
	$(RM) $(OBJDIR)memalign.out $(OBJDIR)memalign.makefile.copy

# The following variables are used when testing the various memory range knobs (see tests below).
ZERO_BASED_REGION := 0:0x80000000

ifeq ($(TARGET),ia32)
    MEMORY_BOUNDARY_TO_CHECK := 0xBadBeef:0x1BadBeef
    CC_BOUNDARY_TO_CHECK := 0x1BadBeef:0x3BadBeef
    PIN_IMAGE_RANGE := 0x50000000:0x60000000
    PIN_IMAGE_RANGE_PARAM := -pin_image_memory_range $(PIN_IMAGE_RANGE)
    PIN_RESTRICT_RANGE_PARAM := -restrict_memory 0x1048000:0x1058000
endif
ifeq ($(TARGET),intel64)
    MEMORY_BOUNDARY_TO_CHECK := 0x20BadBeef:0x21BadBeef
    CC_BOUNDARY_TO_CHECK := 0x30BadBeef:0x32BadBeef
    PIN_IMAGE_RANGE := 0x500000000:0x600000000
    PIN_IMAGE_RANGE_PARAM := -pin_image_memory_range $(PIN_IMAGE_RANGE)
    PIN_RESTRICT_RANGE_PARAM := -restrict_memory 0x304000000:0x304010000
endif
ifeq ($(TARGET),mic)    
    MEMORY_BOUNDARY_TO_CHECK := 0x20BadBeef:0x21BadBeef
    CC_BOUNDARY_TO_CHECK := 0x30BadBeef:0x32BadBeef
    PIN_IMAGE_RANGE := 0:0
    PIN_IMAGE_RANGE_PARAM :=
endif

# -pin_image_memory_range is not supported on Windows and OS X*.
ifeq ($(TARGET_OS),mac)
    PIN_IMAGE_RANGE := 0:0
    PIN_IMAGE_RANGE_PARAM :=
    ifeq ($(TARGET),intel64)
        # On OS X* 64 bit the lowest 4GB cannot be allocated so we're using
        # the region 0:0x180000000 which is actually 0x100000000:0x180000000 
        ZERO_BASED_REGION := 0:0x180000000
    endif
endif
ifeq ($(TARGET_OS),windows)
    PIN_IMAGE_RANGE := 0:0
    PIN_IMAGE_RANGE_PARAM :=
endif

# The following tests check the memory range knobs.
address_mapping.test: $(OBJDIR)address_mapping$(PINTOOL_SUFFIX) $(OBJDIR)mmap_reader_app$(EXE_SUFFIX)
	$(RM) -f $(OBJDIR)address_mapping.out $(OBJDIR)mmap_reader_app.out
	$(PIN) -xyzzy -cc_memory_range $(CC_BOUNDARY_TO_CHECK) -pin_memory_range $(MEMORY_BOUNDARY_TO_CHECK) \
	  $(PIN_IMAGE_RANGE_PARAM) \
	    -t $(OBJDIR)address_mapping$(PINTOOL_SUFFIX) -o $(OBJDIR)address_mapping.out -c $(CC_BOUNDARY_TO_CHECK) \
	      -b $(MEMORY_BOUNDARY_TO_CHECK) -- $(OBJDIR)mmap_reader_app$(EXE_SUFFIX) > $(OBJDIR)mmap_reader_app.out
	$(QGREP) "Test successful" $(OBJDIR)address_mapping.out
	if [ "$(PIN_IMAGE_RANGE)" != "0:0" ]; then \
	  $(QGREP) "\<0*$(word 2, $(subst x, , $(subst :, ,$(PIN_IMAGE_RANGE))))-.*/pin" $(OBJDIR)mmap_reader_app.out && \
	    $(QGREP) -- "-0*$(word 4, $(subst x, , $(subst :, ,$(PIN_IMAGE_RANGE))))\>" $(OBJDIR)mmap_reader_app.out; fi
	$(RM) $(OBJDIR)address_mapping.out $(OBJDIR)mmap_reader_app.out

# The following tests check the memory range knobs.
address_mapping_zero.test: $(OBJDIR)address_mapping$(PINTOOL_SUFFIX) $(OBJDIR)mmap_reader_app$(EXE_SUFFIX)
	$(RM) -f $(OBJDIR)address_mapping_zero.out $(OBJDIR)mmap_reader_app_zero.out
	$(PIN) -xyzzy -pin_memory_range $(ZERO_BASED_REGION) \
	    -t $(OBJDIR)address_mapping$(PINTOOL_SUFFIX) -o $(OBJDIR)address_mapping_zero.out -c $(ZERO_BASED_REGION) \
	      -b $(ZERO_BASED_REGION) -- $(OBJDIR)mmap_reader_app$(EXE_SUFFIX) > $(OBJDIR)mmap_reader_app_zero.out
	$(QGREP) "Test successful" $(OBJDIR)address_mapping_zero.out
	$(RM) $(OBJDIR)address_mapping_zero.out $(OBJDIR)mmap_reader_app_zero.out

address_mapping_oom.test: $(OBJDIR)address_mapping$(PINTOOL_SUFFIX) $(TESTAPP)
	$(RM) -f $(OBJDIR)address_mapping_oom.out
	! ( $(PIN) -xyzzy -pin_memory_range $(MEMORY_BOUNDARY_TO_CHECK) -cc_memory_range 0:0 \
	  -t $(OBJDIR)address_mapping$(PINTOOL_SUFFIX) -o $(OBJDIR)address_mapping_oom.out -m 1 -b $(MEMORY_BOUNDARY_TO_CHECK) \
	    -- $(TESTAPP) makefile $(OBJDIR)address_mapping_oom.makefile.copy )
	$(QGREP) "Failed to allocate dynamic memory" $(OBJDIR)address_mapping_oom.out
	$(RM) $(OBJDIR)address_mapping_oom.out $(OBJDIR)address_mapping_oom.makefile.copy

address_mapping_probe.test: $(OBJDIR)address_mapping_probe$(PINTOOL_SUFFIX) $(TESTAPP)
	$(RM) -f $(OBJDIR)address_mapping_probe.out
	$(PIN) -xyzzy -probe -pin_memory_range $(MEMORY_BOUNDARY_TO_CHECK) -cc_memory_range 0:0 \
	  -t $(OBJDIR)address_mapping_probe$(PINTOOL_SUFFIX) -o $(OBJDIR)address_mapping_probe.out \
	    -b $(MEMORY_BOUNDARY_TO_CHECK) -- $(TESTAPP) makefile $(OBJDIR)address_mapping_probe.makefile.copy
	$(QGREP) "Test successful" $(OBJDIR)address_mapping_probe.out
	$(RM) $(OBJDIR)address_mapping_probe.out $(OBJDIR)address_mapping_probe.makefile.copy

restrict_memory.test: $(OBJDIR)mmap_reader_app$(EXE_SUFFIX)
	$(RM) -f $(OBJDIR)restrict_memory.out
	$(PIN) $(PIN_RESTRICT_RANGE_PARAM) -- $(OBJDIR)mmap_reader_app$(EXE_SUFFIX) > $(OBJDIR)restrict_memory.out
	! ( $(GREP) "/pin\>"  $(OBJDIR)restrict_memory.out |  $(QGREP) \
	  "\<0*$(word 3, $(subst x, , $(subst :, ,$(PIN_RESTRICT_RANGE_PARAM))))-" )
	$(RM) $(OBJDIR)restrict_memory.out

restrict_memory_vdso.test: $(OBJDIR)restrict_memory_vdso$(PINTOOL_SUFFIX) $(OBJDIR)print_vdso$(EXE_SUFFIX) $(DISABLE_ASLR)
	$(RM) -f $(OBJDIR)restrict_memory_vdso.out $(OBJDIR)the_vdso.txt
	$(DISABLE_ASLR) $(PIN) -- $(OBJDIR)print_vdso$(EXE_SUFFIX) > $(OBJDIR)the_vdso.txt
	$(DISABLE_ASLR) $(PIN) -restrict-memory `cat $(OBJDIR)the_vdso.txt` \
	  -t $(OBJDIR)restrict_memory_vdso$(PINTOOL_SUFFIX) -- $(OBJDIR)print_vdso$(EXE_SUFFIX) \
	    > $(OBJDIR)restrict_memory_vdso.out
	$(DISABLE_ASLR) $(PIN) -restrict-memory 0x30000:0x31000 -t $(OBJDIR)restrict_memory_vdso$(PINTOOL_SUFFIX) \
	  -success -- $(OBJDIR)print_vdso$(EXE_SUFFIX) > $(OBJDIR)restrict_memory_vdso.out
	$(DISABLE_ASLR) $(PIN) -t $(OBJDIR)restrict_memory_vdso$(PINTOOL_SUFFIX) -success \
	  -- $(OBJDIR)print_vdso$(EXE_SUFFIX) > $(OBJDIR)restrict_memory_vdso.out
	$(RM) $(OBJDIR)restrict_memory_vdso.out $(OBJDIR)the_vdso.txt

restrict_memory_stack.test: $(OBJDIR)print_stack$(EXE_SUFFIX) $(DISABLE_ASLR)
	$(RM) -f $(OBJDIR)restrict_memory_stack.out $(OBJDIR)the_stack.txt
	$(DISABLE_ASLR) $(PIN) -- $(OBJDIR)print_stack$(EXE_SUFFIX) > $(OBJDIR)the_stack.txt
	# The program below will crash if area adjacent to the stack is not maped correctly
	$(DISABLE_ASLR) $(PIN) -xyzzy -reserve_memory $(OBJDIR)the_stack.txt \
	  -- $(OBJDIR)print_stack$(EXE_SUFFIX) > $(OBJDIR)restrict_memory_stack.out
	$(RM) $(OBJDIR)restrict_memory_stack.out $(OBJDIR)the_stack.txt

memory_limit.test: $(OBJDIR)memory_limit$(PINTOOL_SUFFIX) $(TESTAPP)
	$(RM) -f $(OBJDIR)memory_limit.out
	! ( $(PIN) -pin_memory_size 0x10000000 -t $(OBJDIR)memory_limit$(PINTOOL_SUFFIX) -b 0x10000000 -o $(OBJDIR)memory_limit.out \
	  -- $(TESTAPP) makefile $(OBJDIR)address_mapping_oom.makefile.copy )
	$(QGREP) "Failed to allocate dynamic memory with size" $(OBJDIR)memory_limit.out
	$(RM) -f $(OBJDIR)memory_limit.out $(OBJDIR)address_mapping_oom.makefile.copy


##############################################################
#
# Build rules
#
##############################################################

# This section contains the build rules for all binaries that have special build rules.
# See makefile.default.rules for the default build rules.

ifeq ($(TARGET_OS),windows)
    ACCESS_PROTECTION_APP_EXPORTS := /EXPORT:NotifyPinAfterMmap
endif

###### Special applications' build rules ######

$(OBJDIR)access_protection_app$(EXE_SUFFIX): access_protection_app.cpp
	$(APP_CXX) $(APP_CXXFLAGS_NOOPT) $(COMP_EXE)$@ $< $(APP_LDFLAGS_NOOPT) $(ACCESS_PROTECTION_APP_EXPORTS) $(APP_LIBS)

$(OBJDIR)new_delete_app$(EXE_SUFFIX): new_delete_app.cpp $(THREADLIB)
	$(APP_CXX) $(COMPONENT_INCLUDES) $(APP_CXXFLAGS) $(COMP_EXE)$@ $^ $(APP_LDFLAGS) $(APP_LPATHS) $(APP_LIBS) $(APP_LIB_ATOMIC) $(CXX_LPATHS) $(CXX_LIBS)
